---
title: Structural Patterns
layout: remark
permalink: /structural
---

class: center, middle, inverse

# Structural Patterns
## Diseño Avanzado Orientado a Objetos

---

# Structural Patterns

- Façade
- Adapter
- Decorator
- Bridge
- Composite
- Proxy

???

Structural patterns are concerned with how classes and objects are composed to form larger structures

---

# Façade

![](3-structural/facade.png)

---

# Façade

- Provide a unified interface to a set of interfaces in a subsystem

???

Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.

--

- Façade defines a higher-level interface that makes the subsystem easier to use

--

- Applicability:

 - Provide a simple interface to a complex subsystem (the application of design patterns often results in a lot of small classes which makes subsystems more flexible and customizable)

--

 - Reduce coupling between clients-subsystems or subsystems-subsystems

--

 - To layer your subsystems

---

# Façade

![](3-structural/facade-dep.png)

---

# Adapter

![](3-structural/adapter.png)

---

# Adapter

- Convert the interface of a class into another interface clients expect

???

Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.

--

- Adapter lets classes work together that couldn't otherwise because of incompatible interfaces

--

- Applicability: When you want to use an existing class, and its interface does not match the one you need

---

# Object Adapter

![](3-structural/object-adapter.png)

---

# Object Adapter

- Pros

 - Allow the client and the adaptee to be decoupled
 - Works with Adaptee and all of its subclasses

--

- Cons
 - Requires more code

---

# Class Adapter

![](3-structural/class-adapter.png)

---

# Class Adapter

- Pros

 - Can override Adaptee’s behaviour
 - Less code required

--

- Cons
 - Requires sub-classing (A problem for single inheritance)

---

# Adapter vs Façade

- A Façade simplifies an interface

--

- An Adapter converts an interface into an existing one

--

- Façade are oriented to hide complex subsystems

---

# Decorator

![](3-structural/decorator.png)

---

# Decorator

![](3-structural/decorator-mess.png)

---

# Decorator

- The decorator pattern applies when there is a need to dynamically add as well as
remove responsibilities to a class, and when subclassing would be impossible due to the
large number of subclasses that could result

???

Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.

Sometimes we want to add responsibilities to individual objects, not to an entire class.

---

# Decorator

![](3-structural/decorator-nice.png)

---

# Decorator

![](3-structural/decorator-pic.png)

---

# Bridge

![](3-structural/schedule-1.gif)

???

Decouple an abstraction from its implementation so that the two can vary independently.

---

# Bridge

![](3-structural/schedule-2.gif)

---

# Bridge

![](3-structural/schedule-3.gif)

---

# Bridge

- The intent of this pattern is to decouple abstraction from implementation so that the two can vary independently

--

- Publish interface in an inheritance hierarchy, and bury implementation in its own inheritance hierarchy

---

# Bridge

![](3-structural/bridge.png)

---

# Bridge

![](3-structural/bridge-example.png)

---

# Bridge, when?

- You want run-time binding of the implementation
- You have a proliferation of classes resulting from a coupled interface and numerous implementations
- You want to share an implementation among multiple objects
- You need to map orthogonal class hierarchies

???

Decide if two orthogonal dimensions exist in the domain. These independent concepts could be: abstraction/platform, or domain/infrastructure, or front-end/back-end, or interface/implementation.
Design the separation of concerns: what does the client want, and what do the platforms provide.
Design a platform-oriented interface that is minimal, necessary, and sufficient. Its goal is to decouple the abstraction from the platform.
Define a derived class of that interface for each platform.
Create the abstraction base class that "has a" platform object and delegates the platform-oriented functionality to it.
Define specializations of the abstraction class if desired

---

# Composite

![](3-structural/composite.png)

???

Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.

---

# Composite

- Compose objects into tree structures to represent whole-part hierarchies

--

- Composite lets clients treat individual objects and compositions of objects uniformly

???

The key to the Composite pattern is an abstract class that represents both primitives and their containers

--

- Recursive composition

---

# Composite

![](3-structural/composite-class.png)

---

# Proxy

![](3-structural/proxy-aunty.png)

???

Provide a surrogate or placeholder for another object to control access to it.

---

# Proxy

Use an extra level of indirection to support distributed, controlled, or intelligent access

---

# Proxy

![](3-structural/proxy-check.png)

---

# Rules of thumb

- Adapter makes things work after they're designed; Bridge makes them work before they are.

--

- Bridge is designed up-front to let the abstraction and the implementation vary independently. Adapter is retrofitted to make unrelated classes work together.

--

- Adapter provides a different interface to its subject. Proxy provides the same interface. Decorator provides an enhanced interface.

--

- Adapter is meant to change the interface of an existing object. Decorator enhances another object without changing its interface. Decorator is thus more transparent to the application than an adapter is. As a consequence, Decorator supports recursive composition, which isn't possible with pure Adapters.

--

- Facade defines a new interface, whereas Adapter reuses an old interface. Remember that Adapter makes two existing interfaces work together as opposed to defining an entirely new one.
